# Chapter 03 프로세스와 스레드

## 정리
준비상태나 대기상태는 큐 방식으로 운영된다.  
각 상태마다 다양한 큐가 있는데 이때 동일한 입출력기준으로 큐에 프로세스가 배정된다.  
각 큐에 다양한 프로세스들이 몰려있으니까 이를 관리할 수 있게 프로세스정보를 가지고있는게 PCB이다.  
PCB안에 포인터를 통해서 pcb들을 연결해서 줄을 세움.  


## 01 프로세스의 개요

### 1. 프로세스의 개념

1. 프로그램 실행이란 ? 코드가 메모리에 올라와서 작업이 진행되는 것
2. 프로그램은 저장자치에 저장되어있는 정적인 상태
3. 프로세스는 실행을 위해 메모리에 올라온 동적인 상태
4. 프로그램 : 어떤 데이터를 사용하고 어떤 작업을 할지 절차를 적은 것
5. 프로세스 : 작성한 프로그램이 실행되는 것
6. 레시피 : 어떻게 조리 할지 절차 적어놓은것
7. 요리 : 실제 구현, 레시피에 따라 조리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd3d4c40-699b-424a-9131-9e7494a42c5e/Untitled.png)

### 2. 요리사 모형에의 비유

1. 주문서의 역할 : 요리의 전반적인 조리 방법과 요리가 나가는 **순서 결정**
2. 일괄 작업 방식의 요리 : 레스토랑에 테이블이 하나만 있는 것
    1. 테이블이 하나라서 그 테이블만 손님을 받을 수 있고, 손님이 나가면 다음 손님을 받을 수 있음
    2. 한번에 한 가지 요리 
    3. 작업 효율이 떨어짐
    4. 주문 목록이 큐로 처리된다. (먼저 들어온 데이터가 먼저 나가는 자료구조)
3. 시분할 방식의 요리
    1. 요리사는 1명이지만 여러가지 요리를 동시에 하는 것
    2. 마치 요리가사 여려 명이 있는 것 처럼 모든 테이블에 요리 제공
    3. CPU가 시간을 쪼개서 여러 프로세스에 적당히 배분함 = 동시에 실행하는 것 처럼 느껴짐
4. 시분할 방식에서의 예상치 못한 상황 처리
    1. 새우튀김를 해야하는데 새우가 아직 손질 안됐다면 대기목록으로 옮기고 다른 주문서의 요리 준비
    2. 현대의 운영체제는 시분할 방식을 기본으로 사용
    3. 프로세스가 여러 상태를 오가며 실행된다.
    

### 3. 프로그램에서 프로세스로의 전환

1. 프로세스 = 태스크 = 컴퓨터 시스템의 작업 단위
2. 운영체제가 프로그램을 메모리의 적당한 위치로 가져온다. 동시에 작업 지시서를 만든다.
3. 이 작업 지시서를 프로세스 제어 블록 이라고 한다.
4. 프로세스 제어 블록 : 프로세스를 처리하는 데 필요한 다양한 정보가 들어감.
5. 프로그램이 프로세스가 되었다 ? → 운영체제로부터 프로세스 제어 블록을 받았다.
6. 프로그램이 프로세스가 되려면 메모리에 올라오는 것과 동시에 프로세스 제어 블록이 생성된다.
7. **프로세스 제어 블록 구성요소 세 가지** (더 자세한건 뒤에)
    1. 프로세스 구분자 : PID (Process Identification) , 여러개의 프로세스를 구분하기위한 구분자.
    2. 메모리 관련 정보 : 프로세스의 메모리 위치 정보 
    3. 각종 중간 값 : 여러 프로세스가 번갈아 가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPU를 넘겨준다. (= 현재 어떤 단품요리가 손님한테 제공되었는지 주문서에 표시하는 것)
8. 프로세스 제어 블록은 운영체제가 해당 프로세스를 관리하는 데이터 구조
9. 운영체제 영역에 만들어짐
10. 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기됨
11. 프로세스 = 프로그램 + 프로세스 제어 블록
12. 프로그램= 프로세스 - 프로세스 제어 블록

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7320bc85-7141-49da-9817-240ea369684a/Untitled.jpeg)

### 4. 프로세스의 상태

1. 운영체제에서 여러 가지 이유로 프로세스 상태가 변화
2. 일괄 작업 시스템의 프로세스 상태 : 생성→실행→완료
3. 시분할 시스템의 프로세스 상태 : 
    1. CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번해서 상태가 복잡하게 변함
    2. 마치 여러개의 코스요리 주문이 있을때 단품 요리를 번갈아가면서 만드는 것
4. 프로세스의 네 가지 상태
    1. 생성 상태 : 프로그램을 메모리에 가져와 실행 준비 완료한 상태, PCB 생성
    2. 준비 상태 : 생성된 CPU를 얻을 때까지 기다리는 상태. 프로세스가 자기 실행순서가 될때까지 준비상태에서 기다림
        1. CPU 스케줄러가 다음 실행할 프로세스 선정
        2. 준비상태→실행상태 : 디스패치
        3. 큐(선입선출)
    3. 실행 상태 : 준비상태에 있는 프로세스 중 하나가 CPU를  얻어 실제 작업을 수행하는 상태, 이때 주어진 시간을 다 사용하고도 작업이 끝나지 않으면 다시 준비상태로 돌아감.
        1. 타임아웃 : 프로세스가 주어진 시간동안 작업을 못끝내면 다시 준비상태로 돌아가는 것 
    4. 완료 상태 : 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입. PCB이 사라짐
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9ab1beb-fd7f-4ffe-b29d-a218570b5e02/Untitled.jpeg)
    
5. 프로세스의 다섯 가지 상태
    1. 오늘날 운영체제의 효율성의 고려해 한가지 상태가 더 만들어짐 : 대기 상태
    2. 대기 상태 : 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
    3. 작업의 효율성을 높이기 위해 입출력을 요청한 프로세스를 대기상태로 옮김
    4. 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU스케줄러가 준비 상태에 있는 프로세스 중 하나를 실행함.
    5. 큐(선입선출)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b9a0c21-2fc4-4e8b-88e5-ad62de0ff9e1/Untitled.jpeg)
    
    ## 02 프로세스 제어 블록과 문맥 교환
    
    ### 1. 프로세스 제어 블록
    
    1. 프로세스를 실행하는데 필요한 정보를 보관하는 자료구조
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d82939a0-ecd2-4d3e-9fcc-d244c54ace1a/Untitled.png)
    
    - 포인터 : 준비상태나 대기 상태의 큐를 구현할때 포인터 사용
        - 대기 상태에 같은 입출력을 요구한 프로세스끼리 모음
        - 동일한 입출력 큐에 모음 : 대기 큐
    - 프로세스 상태 : 생성,준비,실행,대기 등
    - 프로세스 구분자 : 여러 프로세스를 구분하기 위함
    - 프로그램 카운터 : 명령어의 위치를 가리키는 프로그램카운터의 값 저장
    - 프로세스 우선순위 : 우선순위에 따라 프로세스 제어 블록들이 여러 줄로 있음. CPU 스케줄러에 의해 높은 우선순위의 프로세스를 먼저 실행되고 자주 실행됨
    
    ### 2. 문맥교환
    
    1. 요리작업의 전환 과정 : 주문서를 바꾸는 것 + 작업 환경을 바꾸는 것
    2. 문맥교환 : CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
    3. 문맥 교환 절차 :
        1. P1프로세스가 자신에게 주어진 시간을 다 사용하면 P1의 프로세스 제어 블록에 현재까지 작업 결과가 저장되고 P1은 준비상태로 쫓겨남.
        2. P2가 실행 상태로 변경되고 CPU의 레지스터가 P2의 프로세스 제어 블록값으로 채워짐
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/20aed9aa-0a36-4595-9dff-2d1f43858bfb/Untitled.jpeg)
        
    

## 03 프로세스의 연산

### 1. 프로세스의 구조

| 프로세스 | 요리 | 설명 |
| --- | --- | --- |
| 코드 영역 | 요리책 | 코드영역에 프로세스의 본문이 기술됨
프로그래머가 작성한 것이 탑재
읽기 전용으로 처리 |
|  데이터 영역 | 재료 | 프로세스의 데이터 영역
사용하는 변수나 파일 모아둠
읽기,쓰기가 가능 |
| 스택 영역 | 조리 도구 | 코드를 작동하기 위해 운영체제가 관리하는 영역
사용자에게 보이지않음 |

ex. 워드 프로세서 프로그램 실행시 이 프로그램은 코드 영역에 탑재, 워드프로세서로 편집 중인 문서는 데이터 영역에 탑재, 운영체제가 이를 작동하기 위해 사용하는 각종 부가 데이터는 스택영역에서 관리

### 2. 프로세스의 생성과 복사

1. 사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록 생성 → 메모리에 데이터 영역과 스택 영역을 확보 → 프로세스 실행
2. 손님이 밀려들어 같은 요리를 만들어야 할때 요리를 복제하는것
3. fork() 시스템 
    1. 실행 중인 프로세스를 복사하는 함수. 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식프로세스
    2. 워드프로세스 작성중 하나더 실행하면 운영체제는 fork() 시스템 호충을 사용해 기존 워드프로세서를 복사. 처음 워드프로세서 실행하는 속도보다 빠름
    3. 크롬에서 크롬하나를 더 실행할때 현재의 프로세스를 복사.
    4. fork() 시스템 호출의 장점
        1. 프로세스의 생성 속도가 빠름
        2. 추가 작업 없이 자원 상속
        3. 시스템 관리 효율적 (자식 프로세스 종료시 부모가 정리)

### 3. 프로세스의 전환

- fork()시스템 호출로 요리를 복사 → 복사된 요리를 새로운 요리로 바꾸는 함수 exce()
- 스파게티를 우동으로 바꾸는 것
- 현재의 프로세스가 완전히 다른 프로세스로 전환
- 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출
- 프로세스의 구조체 재활용 : 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모- 자식관계 그대로 사용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dc397fe-0b41-4566-9be1-414c8fe1b9b3/Untitled.png)

## 04 스레드

### 1. 스레드의 개념

프로세스의 코드에 정의된 절차에 따라 CPU에 작업요청을 하는 실행 단위

- 스레드 : 레시피의 정해진 절차에 따라 요리하는 것 : 고기와 채소를 굽고 소스를 뿌린다. 각 각의 조리
- 프로세스 : 요리 작업 전체 (안심 스테이크 만들기)
- CPU스케줄러가 CPU에 전달하는 일하나가 스레드, CPU가 처리하는 작업의 단위
- 운영체제 입장에서 작업 단위는 프로세스
- CPU 입장에서 작업 단위는 스레드

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae1fc15b-8659-41d3-9f07-064194f1ce01/Untitled.png)

 **프로세스와 스레드의 차이**

- 프로세스 끼리 약하게 연결 (주문서끼리 약하게 연결)
- 스레드는 프로세스 내부에서 서로 강하게 연결 (고기굽기 + 채소굽기 + 소스 뿌리기)
- 멀티태스크 : 필요할때 출력할 데이터를 주고 받음
    - 운영체제가 CPU에 작업을 줄때 스레드의 시간을 배분
    - 시분할 시스템
- 멀티스레드 : 스레드들이 동시에 작업
    - 여러 개의 스레드로 분할, 작업의 부담을 줄임
    - 워드프로세서가 종료되면 프로세스 내의 스레드도 강제종료됨
    - 운영체제가 소포트웨어적으로 프로세스를 작은 단위의 스레드로 분할하여 운영
- 멀티프로세싱 : CPU를 여러개 사용해서 여러개의 스레드를 동시에 처리
    - 여러개의 CPU 혹은 CPU내 여러개의 코어에 스레드를 배정
- CPU 멀티스레드
    - 동시에 여러 스레드를 처리하는 병렬 처리 기법
    - 하드웨어적인 방법
    - CPU에서 여러 스레드를 동시에 처리

옛날에는 작업 단위가 프로세스 하나라서 프로세스와 스레드를 구분하지 않음

지금의 운영체제는 프로세스를 다양한 스레드로 나누어 여러개의 코어에 배분→시스템의 효율 높임

### 2. 멀티스레드의 구조와 예

2.1 멀티 스레드의 구조

코드, 데이터 등을 공유하면서 여러개의 일을 하나의 프로세스 내에서 하는 것

- 정적인 영역 : 프로세스가 실행되는 동안 바뀌지 않는 영역
- 동적인 영역 : 스레드가 작업을 하면서 값이 바뀌거나 사라지는 영역 ( 레지스터값, 스택, 힙)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2461cc8-1995-4b81-b1a2-0e755940a1d7/Untitled.png)

- 왼쪽그림처럼 fork() 시스템 호출로 여러개의 프로세스를 만들면 필요없는 정적 영역이 여러개 생성→ 메모리 낭비
- 멀티스레드가 이런 문제 해결 → 여러개의. 스레드를 생성해서 코드, 파일등의 자원을 공유→ 자원의 낭비를 막고 효율성 향상

2.2 멀티스레드의 장단점

장점

- 응답성 향상 : 다른 스레드가 사용자 작업 요구에 빠른 응답
- 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성, 프로세스가 가진 자원을 모든 스레드가 공유, 작업이 원활
- 효율성 향상 : 불필요한 자원의 중복 막음
- 다중 CPU 지원

단점

- 인터넷 익스플로러는 하나의 프로세스에 멀티스레드를 사용
    - 모든 스레드가 자원을 공유해서 한 스레드에 문제가 생기면 전체 프로세스에 영향
    - 문제가 있는 화면을 강제 종료하면 인터넷 익스플로러 전체가 종료
- 크롬은 여러개의 프로세스 사용
    - 자원 낭비
    - 프로세스가 독립적, 서로 영향x

### 동적 할당 영역과 시스템 호출

1. 프로세스의 동적 할당 영역

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fd569ce-d3ab-4c48-86e4-4d08c47aa0ab/Untitled.png)

- 코드 영역 : 프로그램의 본체
- 데이터 영역 : 변수와 데이터
- 코드와 데이터 영역은 프로세스가 실행되기 전에 위치와 크기가 결정. 정적 할당 영역
- 스택, 힙 영역은 프로세스가 실행되는 동안 만들어지는 영역. 동적 할당 영역
1. 스택 영역
    1. 호출한 함수가 종료되면 함수를 호출하기 전 코드로 되돌아가기 위한 메모리의 주소를 스택에 저장 . 함수 호출과 복귀 시에 스택이 사용
    2. 가장 먼저 들어간 데이터가 가장 나중에 나오는 자료 구조.
    3. 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당 영역. 스레드가 진행됨에 따라 커지기도하고 작아지기도 함
    4. 에를 들어 계산기 프로그램에서 사용자의 입력에 따라 함수 사용이 달라진다.
2. 힙영역
    1. 동적으로 할당되는 변수 영역
    2. 대부분의 데이터는 데이터 영역에 할당, 일부 데이터는 프로그램이 실행되는 동안 할당
    3. 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3374dd07-78c6-42e7-a263-0e32ed30d968/Untitled.png)
    
    - sarr 데이터 영역에 50개 짜리 정수 배열이 자리 차지
    - darr은 빈 상태로 실행 → malloc()함수를 만나야 메모리에 자리르 자지
    - sarr는 데이터 영역에 50개의 정수 배열 . 사용하든 안하든 프로세스가 종료될 때까지 메모리를 차지
    - darr은 힙영역에 50개의 정수 배열. 피리용벗어지면 free()함수로 메모리 영역 반환. 필요할때 메모리를 차지했다가 필요없으면 메모리 반환
    - 워드프로세서 프로그램을 만든다면 사용자가 얼마나 큰 문서를 만들지 알 수 없기때문에 배열 크기를 결정할 수 없음. 미리 큰 공간을 만드는것은 메모리 낭비 및 시스템이 느려짐
    
    
    
Chapter 3
[연습문제]

 

1. 프로그램이 프로세스가 되려면 운영체제로부터 무엇을 받아야 하는가?

- 프로세스 제어 블록 (Process Control Block)

 

2. 프로세스의 상태 중 CPU를 할당받기 위해 기다리는 상태는 무엇인가?

- 준비 상태 (Ready status)

 

3. 프로세스의 상태 중 입출력 작업을 하기 위해 이동하는 상태는 무엇인가?

- 대기 상태 (Blocking status)

 

4. CPU 스케줄러가 준비 상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업을 무엇이라고 하는가?

- 실행 상태 (Running status)

 

5. 유닉스에서 Ctrl + Z 키를 눌러 프로세스가 중단되면 프로세스는 어떤 상태로 바뀌는가?

- 휴식 상태 (Pause status)

 

6. 실행 상태에서 하나의 프로세스가 나가고 새로운 프로세스가 들어오는 상황을 무엇이라고 하는가?

- 문맥 교환 (Context Switching): 두 프로세스 제어 블록의 내용이 변경된다. 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 세팅된다. 이렇게 두 프로세스의 프로세스 제어 블록을 교환하는 작업을 말한다.

 

7. 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출은 무엇인가?

- fork(): 실행중인 프로세스와 똑같은 프로세스가 하나 더 만들어진다. 프로세스를 복사할 때 기존의 프로세스는 부모 프로세스가 되고 새로 생긴 프로세스는 자식 프로세스가 되며, 두 프로세스는 부모-자식 관계로 연결된다.

 

8. 프로세스의 골격은 그대로 둔 채 코드 영역만 바꾸는 시스템 호출은 무엇인가?

- exec(): 목적은 프로세스의 구조체를 재활용하기 위함. 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음. 새로운 코드 영역만 가져오면 됨. 

 

9. 부모 프로세스가 기다리지 않아 자원이 회수되지 못하고 계속 살아 있는 프로세스는 무엇인가?

- 고아 프로세스 or 좀비 프로세스

 

10. 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위로서 가벼운 프로세스라고 불리는 것은 무엇인가?

- 스레드 (Thread): CPU 스케줄러가 CPU에 전달하는 일 하나가 스레드이다. CPU가 처리하는 작업의 단위.

 

11. 미아 프로세스를 방지하기 위해 부모 프로세스는 어떤 시스템 호출을 사용하는가?

- wait(): 자식 프로세스가 끝나기를 기다렸다가 자식 프로세스가 종료되면 다음 문장을 실행한다.

 

12. 작업이 끝난 프로세스의 자원을 회수하는 행위를 무엇이라고 하는가?

- 가비지 컬렉션 (garbage collection)

 

13. 모든 프로세스를 부모-자식 관계로 만들어 자원 회수를 용이하게 하는 프로세스의 구조는 무엇인가?

- 프로세스 계층 구조

 

[심화문제]

 

1. 다섯 가지 프로세스 상태도를 그리시오

- 준비 상태 -> 실행 상태 -> 대기 상태

- (대기 상태) -> 보류 대기 상태 -> 보류 준비 상태 -> (준비 상태);

 

2. 프로세스의 상태 중 휴식 상태와 보류 상태에 대해 설명하시오

휴식 상태 (pause status): 프로세스가 작업을 일시적으로 쉬고 있는 상태. 휴식 상태는 유닉스에서 프로그램을 실행하는 도중에 ctrl + z 누르면 확인 가능함.
보류 상태 (suspend status): 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다.
메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
프로그램에 오류가 있어서 실행을 미루어야 할 때
바이러스와 같이 악의적은 공격을 하는 프로세스라고 판단할 때
매우 긴 주기로 반복되는 프로세스라서
입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
- 보류 상태는 스왑 영역에 있는 상태고 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태이다.

 

3. 프로세스 제어 블록의 구성에 대해 설명하시오

- 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조이다.

- 포인터, 프로세스 상태, 프로세스 구분자, 프로그램 카운터, 프로세스 우선순위, 각종 레지스터 정보, 메모리 관리 정보, 할당된 자원 정보, 계정 정보, PPID와 CPID 등

 

4. 문맥 교환에 대해 설명하시오

- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업. 이때 두 프로세스 제어 블록의 내용이 변경된다.

 

5. 프로세스를 구성하는 코드 영역, 데이터 영역, 스택 영역에 대해 설명하시오

코드 영역: 프로그램의 본문이 기술된 곳. 텍스트 영역이라고도 함. 탑재된 코드는 읽기 전용으로 처리 된다.
데이터 영역: 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳. 읽기와 쓰기가 가능하다. 
스택 영역: 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳. ex) 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에 저장한다. 사용자에게는 보이지 않는다.
 

6. fork() 시스템 호출의 장점을 설명하시오

- 프로세스를 새로 만들지 않고 fork()로 복사하면 다음과 같은 장점이 있다.

프로세스의 생성 속도가 빠르다.
하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에 자식 프로세스의 생성 속도가 빠름.
추가 작업 없이 자원을 상속할 수 있다.
부모 프로세스가 사용하던 자원을 자식 프로세스에 모두 상속할 수 있다. 
시스템 관리를 효율적으로 할 수 있다.
부모 프로세스 구분자로 연결되어 있기 때문에, 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있다. 
 

7. exec() 시스템 호출을 사용하는 이유를 설명하시오

- exec() 호출은 기존의 프로세스를 새로운 프로세스로 전환하는 함수. 목적은 프로세스 구조체를 재활용하기 위함이다.

- 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있다. 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월함.

 

8. 프로세스 계층 구조의 장점을 설명하시오

- 동시에 여러 작업을 처리하고 종료된 프로세스의 자원을 회수하는데 유용하다.

여러 작업의 동시 처리: fork()와 exec() 메서드를 사용하여 프로세스 계층 구조를 만들어서 새로운 프로세스를 계속 만들기 보다 자원을 더 효율적으로 사용할 수 있다.
용이한 자원 회수: 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월하다. 프로세스가 작업을 마쳐서 자원을 회수할 때 특히 편리하다.
9. 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU 멀티스레드를 비교하여 설명하시오

멀티스레드: 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄임.
멀티태스킹: 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법. 이런 시스템을 시분할 시스템이라고 한다. 시분할 시스템에서 운영체제가 CPU에 전달하는 작업은 프로세스가 아니라 스레드이다.
멀티프로세싱: CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경. 하나의 컴퓨터에 여러 개의 CPU 혹은 하나의 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동하는 것.
CPU 멀티스레드: 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법이다. 프로세스의 멀티스레드와 구분하기 위해 이 책에서는 이렇게 부름.
